---
date: 2020-09-07
title: "Java并发编程笔记-进程与线程"
tags: ["Java", "并发编程", "进程与线程"]
---

### 并发与并行

> 详情可参看另一篇读书笔记《七周七并发模型读书笔记-概述》

#### 并发与并行的区别

- 并发：同一时间段，多个任务都在执行（单位时间内不一定同时执行）

- 并行：单位时间内，多个任务同时执行

### 线程

#### 进程与线程的概念

- 进程：程序的一次执行过程，是系统运行程序的基本单位。操作系统运行一个程序，即是一个进程创建、运行到消亡的过程。

- 线程：与进程类似，但比进程更轻量，创建开销也更小，一个进程在执行过程中可以产生多个线程，在Java程序中，同类的多个线程可以共享进程的堆和方法区资源，但是每个线程都有自己的**程序计数器、虚拟机栈和本地方法栈**。

Java程序天生就是多线程，可通过JMX代码来确定，如下所示：

```groovy
// 用Groovy Spock框架写的单元测试
def "验证Java程序是多线程程序"() {
        given:
        ThreadMXBean mxBean = ManagementFactory.getThreadMXBean()
        // 不需要获取 monitors 和 synchronizer 信息
        ThreadInfo[] threadInfos = mxBean.dumpAllThreads(false, false)
        expect:
        threadInfos.each {
            println "[" + it.threadId + "] " + it.threadName
        }
    }
```

#### 线程与进程区别

- 线程是进程中划分粒度更小的执行单位，各进程之间是独立的，而线程则不一定，因为同一进程中的线程可能会相互受影响；
- 线程执行开销小，但不利于资源管理和保护，而进程刚好相反。

#### 为什么要使用多线程

- 计算机底层角度：线程间的切换和调度成本远远小于进程。
- 互联网发展的趋势：并发量大，多线程是并发编程的基础。
- 现实世界：世界是并发且复杂多变，用并发的软件来与世界交互更简单方便。

#### 并发编程容易遇到的问题

内存泄漏、上下文切换、死锁和受限于硬件和软件的资源闲置问题。

#### 线程的生命周期和状态

|   状态名称   | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
|     NEW      | 初始状态，线程刚创建，还没调用start()方法                    |
|   RUNNABLE   | 运行状态，线程的就绪和运行统称运行中                         |
|   BLOCKED    | 表示线程阻塞于锁                                             |
|   WAITING    | 表示线程处于等待状态，需要其它线程做出一些特定动作（通知或中断） |
| TIME_WAITING | 超时等待状态，超过指定时间后自行返回                         |
|  TERMINATED  | 终止状态，表示线程已执行完毕                                 |

#### 并发编程时为什么不能直接调用线程的run()方法

调用线程的start()方法可启动线程并使线程进入就绪状态，而直接调用run()方法只是一次普通的方法调用，还是在主线程里执行。

#### 什么是线程死锁？如何避免死锁

线程死锁描述的是这样一种情况：

多个线程同时被阻塞，其中的一个或多个线程等待某个资源的释放。由于线程被无限期阻塞，因此程序不可能被正常终止。

线程死锁的条件：

- 互斥条件：该资源任意时刻只能由一个线程持有；
- 请求与保持条件：线程因请求资源阻塞时，对已获得的资源不释放；
- 不剥夺条件：对已获取到的资源，线程在未使用完之前，其它线程无法强行剥夺，且只能由获取线程释放；
- 循环等待条件：若干线程形成头尾交接的循环等待资源的情况。

为了避免死锁，我们只要打破四个条件中的一个即可：

- 破坏互斥条件：这个没法破坏，因为我们使用锁机制出发点就是要让线程互斥访问资源；
- 破坏请求与保持条件：一次性获取所有资源；
- 破坏不剥夺条件：占用部分资源的线程继续获取其它资源时，如果获取失败，主动释放持有的资源；
- 破坏循环等待条件：按序申请资源。



